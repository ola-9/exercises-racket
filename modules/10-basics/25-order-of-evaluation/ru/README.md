
Попробуем превратить выражение `5 - 3 + 1` в программу на Racket. С точки зрения арифметики, порядок вычисления элементов этого составного выражения строго определен. Сначала вычисляется `5 - 3`, затем к получившемуся результату прибавляется единица.

Начнем с того, что вычисляется первым: `5 - 3` превращается в `(- 5  3)`. Затем сложим получившийся результат с единицей: `(+ (- 5 3) 1)`. Так как сложение — это коммутативная операция (Помните "от перемены мест слагаемых сумма не меняется"?), то же самое можно записать и в другом порядке: `(+ 1 (- 5 3))`. Неизменным остается то, что в начале каждого списка находится операция.

Заметьте, выражения, вычисляемые первыми, находятся в глубине дерева. Такое поведение свойственно большинству обычных языков. Сначала вычисляются аргументы функций, затем вызывается сама функция.

Попробуем другой вариант: `5 - (3 + 1)`. В этом выражении скобки устанавливают другой приоритет. Это значит, что сначала вычислится сумма единицы и тройки. Так и запишем: `(+ 3 1)` (или так: `(+ 1 3)`). Теперь возьмём пятерку и вычтем из неё получившийся результат: `(- 5 (+ 1 3))`.

В такие моменты проявляется ещё одна отличительная особенность Lisp-языков. Древовидная структура программы сама определяет последовательность вычисления поддеревьев. Отпадает необходимость использовать дополнительные скобки.

Ещё один пример: `5 + 7 + (8 - 3) - (8 * 5)`. Действуем по привычной схеме:

* `(* 5 8)`
* `(- 8 3)`
* `(+ 5 7 (- 8 3))`
* `(- (+ 5 7 (- 8 3)) (* 5 8))`

В некоторых ситуациях порядок вычисления элементов списка не соответствует порядку их следования. Такое происходит при использовании специальных форм и макросов. Об этом поговорим позже.
