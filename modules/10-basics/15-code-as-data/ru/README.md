
Первый вопрос, который возникает при чтении кода Racket-программы, — почему такая странная запись вызова функции? Вместо привычного `displayln("eat me")` мы видим `(displayln "eat me")`.

Причины такой записи лежат в идее, которая стоит за всеми Lisp-языками. Название "Lisp" расшифровывается как LISt Processor (обработчик списков). [Односвязный список](https://en.wikipedia.org/wiki/Linked_list) — основная структура данных в этих языках. Более того, любая программа на Lisp-языке — сама по себе список! Посмотрите еще раз на эту программу:

```scheme
(displayln "eat me") ; => eat me
```

С одной стороны, это вызов функции `displayln` со строковым аргументом "eat me". С другой — это список из двух элементов: displayln и "eat me". Рассмотрим несколько примеров. Не пытайтесь их понять как код, мы ещё не готовы к этому. Смотрите на них как на обычные списки.

```scheme
(+ 1 2) ; сложение, или список из трёх элементов
(define count 0) ; объявление переменной, или список из трёх элементов
(+ 100 3 8 9) ; сложение, или список из пяти элементов
```

В этом моменте проявляется одна из ключевых особенностей любого Lisp-языка: код на Lisp одновременно является данными Lisp-языка (говорят "код как данные"). Это свойство называется гомоиконичностью и является визитной карточкой данного семейства языков.

Возможно, вас интересует, зачем это нужно? Гомоиконичность даёт возможность писать макросы, работающие с исходным кодом как со списком. Механизм макросов в Lisp-языках — одна из мощнейших вещей в программировании вообще.
