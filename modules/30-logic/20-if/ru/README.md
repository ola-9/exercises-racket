
> (if test-expr then-expr else-expr)

Условная конструкция в Racket — это специальная форма, в которой 4 элемента. Первый — `if`, затем — выражение-предикат (`test-expr`). Если предикат вернул истину, то выполняется `then-expr`, иначе `else-expr`. В Racket `if` всегда содержит ветку `else`.

```scheme
(if (> 3 2) "yes" "no") ; "yes"
```

Подчеркну, что форма `if` — это выражение, а значит у неё есть результат. Это резко отличается от большинства привычных языков, в которых `if` – это специальная инструкция. Выражения делают код проще, а его возможности – шире. Все дальнейшие формы, которые мы рассмотрим, также будут выражениями.

Почему `if` называется особой формой? Давайте разберем на примере.

```scheme
(if (> 3 2) (displayln "yes") (displayln "no")) ; => yes
```

Что напечает на экран эта программа? В нормальных формах сначала вычисляются все элементы формы, а затем уже сама форма. Это так называемый аппликативный порядок вычисления. Он используется в большинстве языков и привычен для большинства программистов. Мы ожидаем, что аргументы функции вычисляются до того как попадут в функцию.

Но в случае с примером выше поведение другое. Оно зависит от результата предиката. То есть в форме `if` выполняется ровно то выражение, которое должно выполняться по логике формы `if`: первое, если предикат вернул истину, и второе, если ложь. Именно поэтому форма является особой. Подобную форму невозможно реализовать на самом языке без механизма макросов (а с макросами — можно).

_Существует и другой порядок, так называемый нормальный порядок вычисления. Самый известный язык, использующий его – Haskell. В этом языке ничто не вычисляется до тех пор, пока не понадобится результат вычисления._
