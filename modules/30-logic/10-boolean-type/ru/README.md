
True и False в Racket представлены значениями `#t` и `#f`. Запись непривычная, но в языках, созданных много лет назад, встречается и не такое. Большинство операций в Racket рассматривают как ложь только `#f`. Всё остальное считается истиной. Пара примеров проверки на равенство:

```scheme
(equal? 42 42) ; #t
(equal? 42 24) ; #f
```

Равенство значений проверяется через функцию `equal?`. Иногда может потребоваться сравнение по ссылке, в таком случае используют `eq?`.

Напишем функцию `gt?`, которая возвращает `#t`, если первое число больше второго и `#f` в другом случае. В Racket имена предикатов заканчиваются вопросительным знаком. При этом к ним не добавляется префикс "is".

```scheme
(define (gt? x y) (> x y))
(gt? 3 2) ; #t
(gt? 10 15) ; #f
```

_Вот так разработчики на Ruby узнали, почему в их языке предикаты выглядят как вопросы :)_

Теперь напишем предикат, определяющий четность числа. Для этого нам понадобится функция `remainder`, которая вычисляет остаток от деления.

```scheme
(define (even? n) (= (remainder n 2) 0))
(even? 3) ; #f
(even? 4) ; #t
```

> Строго говоря, такая функция уже есть в языке. Здесь мы её реализуем заново только ради примера.

Логические операторы в Racket не имеют символьных обозначений, вместо этого используются функции `and`, `or`, `not` и другие.

```scheme
(not "moon") ; #f
(and (odd? 3) (even? 4)) ; #t
```

Как и в случае с арифметическими операциями, мы получаем два бонуса:

1. Префиксная нотация позволяет комбинировать любое число условий: `(and <one> <two> <three> <...>)`.
1. Благодаря древовидной структуре исходного кода приоритет всегда точно определен.
