
Любой список рано или поздно захочется *обойти* (*traverse*), то есть поработать с отдельными элементами. В процедурных языках используются циклы, но многие языки имеют и декларативные средства работы с коллекциями: `map`, `filter`, `reduce`. А ведь сами эти функции пришли в программирование через Lisp!

Racket тоже предоставляет полный набор таких функций. Ближайшие несколько уроков будут посвящены им.

### `map`

Итак, `map` в Racket используется так:

```scheme
(map add1 (list 1 2 3)) ; '(2 3 4)
```

Здесь `add1` — встроенная функция, добавляющая к числу единицу. Всё максимально предсказуемо: `map` превращает старый список в новый, применяя функцию к каждому элементу. Обход получается *функциональный*, потому что мы получаем **новый** список, не меняя старый.

Может `map` обходить и несколько списков одновременно: если применить `map` к нескольким спискам, то функция-аргумент будет применена ко всем первым элементам, затем ко всем вторым и так далее. Но `map` потребует от входных списков иметь одинаковую длину, иначе вы получите ошибку.

Вот так можно поэлементно просуммировать три списка:

```scheme
(map +
     (list 1 2 3)
     (list 10 20 30)
     (list 100 200 300))
; '(111 222 333)
```

Заметьте, не потребовалось даже использовать анонимную функцию, которая складывала бы три числа, ведь функция "`+`" принимает произвольное количество аргументов!
