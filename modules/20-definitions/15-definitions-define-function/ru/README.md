
Функции в Racket обладают следующими свойствами:

* У функций нет имен. Во многих языках такие функции также существуют и называются анонимными функциями или лямбда-функциями.
* Функции являются объектами первого рода. Их можно присваивать переменным, передавать в другие функции и возвращать из функций.

Примеры:

```scheme
; определение функции, вычисляющей сумму двух чисел
(lambda (x y) (+ x y))
```

В примере выше определяется функция с двумя аргументами. Определение функции начинается со слова `lambda`. Вторым элементом в форме определения функции идёт список аргументов. Третий и последующие элементы — тело функции. То есть тело может состоять из нескольких форм (как минимум из одной):

```scheme
(lambda ()
  (displayln "one")
  (displayln "two"))
```

Обратите внимание на отсутствие инструкции `return`. В отличие от большинства других языков, в Lisp-языках инструкций практически нет. Всё есть выражение. А выражения всегда возвращают результат. Если хорошо подумать, то такое поведение следует из самой структуры Lisp-программы. Фактически мы имеем дерево, которое должно вычисляться в какое-то значение, значит на каждом уровне должен создаваться возврат, поднимающийся выше по дереву, и так до самого корня. Возвращается всегда *последнее вычисленное выражение*.

Пара примеров для закрепления:

```scheme
; печать на экран
(lambda () (displayln "hello!"))
; квадрат числа
(lambda (n) (* n n))

; среднее между двумя числами
(lambda (num1 num2) (/ (+ num1 num2) 2))
```

Определение функции само по себе мало полезно, особенно если мы захотим использовать её несколько раз. Для повторного использования нужно создать объявление, в которое запишется функция. Такое возможно благодаря тому, что форма определения функции — это выражение, возвращающее саму функцию.

```scheme
(define square (lambda (n) (* n n)))
```

Теперь попробуем вызвать.

```scheme
(square 7) ; 49
(square 5) ; 25
```
